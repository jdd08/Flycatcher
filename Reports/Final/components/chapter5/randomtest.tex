\chapter{Generating candidate tests}
\label{randomtest}
In this chapter, we detail the process by which \textsf{Flycatcher} generates random candidate tests, in the hope of eventually generating some that can be used to achieve good code coverage of the CUT. First, we explain the structure of a test and some characteristics of that structure. Then we describe the mechanism for trying to generate tests in which the types of the parameters are accurate. Finally, we introduce the concept of custom data generators, for seeding primitive type values inside our tests.

% Finally we discuss the formatting of those tests, with regard to whether they are intended for the \textsf{Executor} or as final output.

\section{Structure}

To recapitulate, an object-oriented test targets a particular method of the CUT, referred to as the MUT. If the method of interest is specified by the user then tests are only generated for that method. Otherwise each of the CUT's methods are selected as the MUT, and tests are generated for each of them, covering the whole class. Either way, generating a test for a MUT involves the following steps:

\begin{enumerate}
	\item Create an instance of the CUT
	\item Call some of its methods (including the MUT) to possibly modify its state
	\item Where the MUT is called (at least once), assert that it returns the expected answer
\end{enumerate}

% \subsubsection{Unit test format}
Assuming that the MUT is the method \texttt{size}, the final output of a valid unit test might therefore look like:

\begin{code}[caption=Unit test,label=final]
var linkedList = new LinkedList();

var node1 = new Node(123);
linkedList.add(node1);

var node2 = new Node(234);
linkedList.add(node2);
assert(linkedList.size() = 2);

var node3 = new Node(345);
linkedList.add(node3);
assert(linkedList.size() = 3);
\end{code}

Note that the format shown in \ref{final} differs from the format of tests that are destined to be run in the \textsf{Executor}. The same test in the \textsf{Executor} needs a structure to keep track of MUT call results, in order to later construct assertions if the test is selected. Example \ref{execformat} illustrates the format of tests in the \textsf{Executor}. In the rest of the examples however, we omit the \texttt{results} structure to keep the examples clear and concise.

% \subsubsection{Executor format}
% 
% For all the results of calling the MUT in a candidate test to be recorded, so that the assertions seen in example \ref{final} can be created, the format of test \ref{final} in the \textsf{Executor} is in fact:
% 
\begin{code}[caption=Executor format,label=execformat]
(function() {
   var results = [];
   var linkedList = new LinkedList();

   var node1 = new Node(123);
   linkedList.add(node1);

   var node2 = new Node(234);
   linkedList.add(node2);
   results[0] = linkedList.size();

   var node3 = new Node(345);
   linkedList.add(node3);
   results[1] = linkedList.size();
   return results;
})();
\end{code}

\subsection{Recursive construction}

The tests are built using recursion, in the sense that when a method call or a constructor call (a declaration) is added to a candidate test, any parameters of that call are declared beforehand. The recursion stops when a constructor call has no parameters \emph{e.g.} in the case of primitives. For the sake of conciseness primitives are in fact inlined as can be seen in the example \ref{final}. So, in the example \ref{final}, the \texttt{LinkedList.add} calls each prompt the declaration of a \texttt{Node} object, which in turn prompts an inline declaration of a number.
The tests \emph{always} start with a declaration of the CUT, and therefore with any declarations that are needed for its constructor's parameters.

The number of method calls made in an attempt to modify the state of the CUT instance is chosen \emph{at random}, with a user-configurable maximum. As we will see in the experimental evaluation, this maximum with regard to the length of method call sequences is significant: it has an effect on code coverage and test readability. However, there must be at least one occurrence of the MUT in the \emph{overall} method call sequence, since the sole purpose of the test is to evaluate that method. Note that if there is only one MUT call, it will be at the end, as there is no use in calling more methods \emph{after} we have finished evaluating the MUT.

We initially made the mistake of making only one MUT call in total, but later realised that this could preclude certain portions of the code from being covered. For example, if \texttt{LinkedList.add} is the MUT, it needs to be called at least twice for a test to exercise full coverage, as the branches taken in the MUT depend on whether the linked list is empty or not.

Aside from its recursive construction, another feature of the tests' structure is the pooling of parameters.

\subsection{Pooling parameters}
In order to reach full coverage, it is important to enable methods in the tests' method call sequences to manipulate references to \emph{the same object}. Let us take a look at the following code:

\begin{code}[caption=Unreachable code,label=unreachable]
var linkedList = new LinkedList();

var node1 = new Node(123);
linkedList.add(node1);
var node2 = new Node(234);
linkedList.remove(node2);
\end{code}

In that example, a substantial portion of the \texttt{LinkedList.remove} method will never be reached: the portion which expects a reference \emph{already contained} in the list. Unless we allow the \texttt{LinkedList.remove} method to use parameters defined previously, without necessarily redefining its own, it is impossible to hand it a reference which exists in the list. In other words, it has to be possible to generate:

\begin{code}[caption=Pooling,label=pooling]
var linkedList = new LinkedList();

var node1 = new Node(123);
linkedList.add(node1);
linkedList.remove(node1);
\end{code}

This is implemented with a `pooling' mechanism. For every type, there is a pool to which objects are added to when they are declared. This enables any subsequent constructor calls or method calls which need a parameter of that type, to reuse a variable which is already declared in the test. Upon a series of experiments, it was determined that a 25\% reuse rate was suitable. The design decision of not making the reuse rate user-configurable was made in order not to overcomplicate \textsf{Flycatcher}'s interface.
% which will be detailed in the evaluation section, it was determined that a 25\% reuse rate gave the best coverage results. However this variable is highly dependent on the program under test and is therefore also configurable if need be.

Note that although tests which are destined to be run in \textsf{Flycatcher}'s custom runtime environment do not have the same format as the ones output to the test suite, they \emph{do} share the same underlying structure which has been described in this section. Although we have discussed how tests are constructed, we have purposely ignored one important detail: \emph{we do not know the types of any of the parameters}. How do we know that the \texttt{LinkedList.add} method takes an object of type \texttt{Node}?

\section{Types}

In generating a test like example \ref{final}, the type of the variable \texttt{linkedList} is known from the start --- it is an instance of the CUT. However, initially, the types of the parameters for the \texttt{LinkedList} and \texttt{Node} constructors are not. For that reason, a special type of object was devised: the \texttt{Unknown} type.

\subsection{\texttt{Unknown} type}

Early on in the test generation process, this object will replace any parameter which we need but do not know the type of. Inside the \textsf{Executor}, these objects enable us to \emph{collect information} about the parameter that they stand for --- we will elaborate on \emph{how} this is done in the next chapter. In most cases, thanks to this information, the \texttt{Unknown} objects are eventually substituted with objects of the appropriate type. However, this is what a test might initially look like:

\begin{code}[caption=Unknown parameter types, label=unknowns]
var linkedList = new LinkedList();

var unknown1 = new Unknown();
linkedList.add(unknown1);

var unknown2 = new Unknown();
linkedList.add(unknown2);
linkedList.size();

var unknown3 = new Unknown();
linkedList.add(unknown3);
linkedList.size();
\end{code}

It is worth noting that tests that contain \texttt{Unknown} objects are \emph{only} destined for the \textsf{Executor}, they are not suitable as final output, regardless of whether they achieve coverage or not (that coverage is in effect meaningless). We will refer to them as invalid tests.

Eventually, after enough information has been collected to infer that the type of the parameter to \texttt{LinkedList.add} is \texttt{Node}, the test would look like:

\begin{code}[caption=After type inference for \texttt{LinkedList.add}, label=firstinference]
   var linkedList = new LinkedList();
   
   var unknown1 = new Unknown();
   var node1 = new Node(unknown1);
   linkedList.add(node1);
   
   var unknown2 = new Unknown();
   var node2 = new Node(unknown2);
   linkedList.add(node2);
   linkedList.size();

   var unknown3 = new Unknown();
   var node3 = new Node(unknown3);
   linkedList.add(node3);
   linkedList.size();
\end{code}

Similarly, when there is enough information to infer that the type of the parameter of the \texttt{Node} constructor is a primitive number, we get the test in example \ref{execformat}.

\subsection{Type inference}
\label{typeinference}
The type information that is collected when tests are run by the \textsf{Executor} is stored in the \texttt{ProgramInfo} object introduced in chapter \ref{analyser}. Upon each \textsf{Test Generator}/\textsf{Executor} iteration for a test, we update \texttt{ProgramInfo} using the type information gathered in the latest \textsf{Executor} run. Although we will explain exactly how this information is collected when we describe the \textsf{Executor}, here we describe how that information is used to infer types for the various test parameters.

\subsubsection{Member accesses}
For each parameter, the \texttt{ProgramInfo} object keeps track of any attempt to access one of its properties. In effect, this records attempts to retrieve \emph{fields} and \emph{methods} from that parameter. By cross-referencing those accesses with the fields and methods stored in \texttt{ProgramInfo}'s class definitions, we may be able to deduce the type of that parameter. If more than one type has fields or methods that match the member accesses of the parameter, the one with the highest correspondence is elected.

During the \texttt{ProgramInfo} type updates, the following questions are asked to try and determine the type of parameters, in that order:

\begin{enumerate}
   \begin{item}
      \emph{Does the parameter have any user-defined member accesses?}\\\(\Rightarrow\) If so select the highest match.
   \end{item}
   \item \emph{Otherwise does the parameter have any member accesses corresponding to the \texttt{\emph{Number}}}\footnote{the object counterpart of the \emph{number} primitive type} \emph{type e.g. \texttt{\emph{toExponential}}?}\\\(\Rightarrow\) If so select the \emph{number} primitive type.
   \item \emph{Otherwise does the parameter have any member accesses corresponding to the \texttt{\emph{String}}}\footnote{the object counterpart of the \emph{string} primitive type} \emph{type e.g. \texttt{\emph{charAt}}?}\\\(\Rightarrow\) If so select the \emph{string} primitive type.
\end{enumerate}

If none of these are true but there are member accesses\footnote{except for the hidden properties inherited from \texttt{Object} in JavaScript which are discounted} which do not match any known type, this means that we are faced with a non-standard or non-supported class which is not accessible in the scope of the program. In that case we abort the test generation process for that particular method with a warning.

If however there are no member accesses, the parameter may be a primitive, in which case we look at its `primitive score' accumulated during \textsf{Executor} runs. Note that the question of whether the parameter has member accesses comes first, as it can rule out the possibility that the parameter is a primitive, but not vice-versa.

\subsubsection{Primitive scoring}
The primitive score of a parameter is an object which accumulates the likelihood of a parameter being of a primitive type based on the operations it is involved in. Like the member accesses, this information is recorded when a candidate test is run in the \textsf{Executor}. The primitive types taken into account are \emph{number} and \emph{string}. We do not deal with \emph{null}, \emph{undefined} and \emph{boolean} as there are no strong hints that can be used to infer any of these types\footnote{the loss in terms of coverage is negligible as in most cases these values produce the same behaviour as \texttt{0} or \texttt{1}}.

% and consider that \emph{boolean} values can be substituted by \texttt{1} or \texttt{0} as the latter are respectively coerced to \texttt{true} and \texttt{false}.
The primitive scoring object thus corresponds to:

\begin{code}[caption=Primitive scoring, label=primitivescore]
   {
      "number" : 15,
      "string" : 12
   }
\end{code}

When type inference takes place for a parameter that is suspected of being a primitive, the most likely primitive type is chosen based on the scores in the accumulator object.

\subsubsection{Delaying type inference}
Because we do not want to jump to conclusions too quickly when inferring types using the member accesses and primitive scores, we do not start updating the \texttt{ProgramInfo} object until a sufficient number of constructor or method calls \emph{involving} that parameter have been made (during the \textsf{Test Generator/Executor} iterations). For example in the following code, the parameter of the \texttt{LinkedList.add} method is involved or `used' in \emph{two} calls.

\begin{code}[caption=Parameter uses,label=uses]
var linkedList = new LinkedList();

var unknown1 = new Unknown();
linkedList.add(unknown1); // first `use' of add's parameter

var unknown2 = new Unknown();
linkedList.add(unknown2); // second `use' of add's parameter
linkedList.size();
\end{code}

This delay, characterised as a minimum number of parameter uses, is user-configurable, as an optimal value for it is highly dependent on the program under test. For example, if a user \emph{knows} that a parameter is only active in a path that is executed infrequently, they may set a high value for the delay before type inference. By making sure that a parameter has had an \emph{adequate} number of opportunities to collect type information, the user can ensure that type inference does not take place too early, when it has a higher chance of being inaccurate. On the other hand, if the user knows that a parameter is active \emph{every time} its function gets called \emph{i.e.} it lies on every path inside that function, the user may want to give the `minimum number of uses' variable a low value to save time.

At first it seemed that a more telling and intuitive measure of confidence about inferring a type for a parameter was how many member accesses had been recorded, or how good the best primitive score was for it. However, any lower limit on such variables makes \emph{too strong assumptions} about the program under test. For example, in a scenario where it is decided that three member accesses provide enough information to make a confident type choice: what if a class only has one or two members?

% Note that the two conditions are a disjunction, they do not need to both be true. Also, even if the first one is never realised, the second will necessarily be realised after a certain number of \textbf{Test Generator}/\textsf{Executor} iterations for that test.

When the delay expires, if the type inference is inconclusive due to the absence of member accesses and null primitive scores, this is a sign that the parameter is seldom or never accessed. However, this parameter will remain an \texttt{Unknown} in the \textsf{Executor} and \textsf{Flycatcher} will not be able to terminate if we do not give it a real type. Hence, we make the leap of faith that, given that the user-configurable delay has expired, the parameter is \emph{not} used and we replace it with a random substitute primitive value, warning the user. An illustration of this scenario is the linked list in Appendix \ref{ll}, as the implementation itself does not make use of the data in the nodes. This is a common pattern which needs to be accounted for. In many cases like this one, the substitution works and enables tests to become valid (rid of \texttt{Unknowns}).

% Finally, there is one last case to deal with: when the second condition is met but we \emph{still} have no information to work with \emph{i.e.} our parameter's properties were not accessed nor was it used in an operation. In such a scenario we assume that given that the test was run a reasonable amount of times (again, this is configurable if the default is not appropriate), it is likely that the parameter is never used. Hence, we replace it with a random primitive, in order to remove any \texttt{Unknowns} from the candidate test, so that it can be output.

% The reasoning is that if a parameter is not used in any way, whatever value we give it has no impact whatsoever. We make the design choice of substituting the unused parameter with a random value rather than aborting the test generation for that method.

In the event that the parameter is in fact used in the program but happened not to be in the delay chosen, tests will fail due to type errors and the user can see that in the logs. They may then adjust the delay variable to suit the needs of their program.

\section{Custom data generators}
When a user-defined type is inferred for a parameter, a suitable object can be constructed in tests using the appropriate class definition, available in the \texttt{ProgramInfo} object. However, regarding the two primitive types \emph{string} and \emph{number} that we are concerned with, a random value needs to be generated.

Many programs require specific input data and simply generating a number from the space of natural numbers or constructing a string from random combinations of ASCII characters will fail to achieve code coverage in those cases. For example, it is infeasible to try and achieve coverage in a program that validates 13-digit International Standard Book Numbers with randomly generated numbers. Hence, \textsf{Flycatcher} is equipped with an extremely convenient way of specifying custom data generators: with regular expressions. The regular expressions that specify a string or a number generator are defined as optional strings on the command line (see usage in section \ref{usagesection}) and they have to conform to a JavaScript \texttt{RegExp}.

The JavaScript library used to \emph{generate} random matches \emph{from} JavaScript regular expressions is \textsf{randexp}, available as a \textsf{Node.js} module\footnote{\url{"https://github.com/benburkert/randexp"}}. Example \ref{custom} shows a \textsf{Flycatcher} custom string generator that generates 4-character long hexadecimal strings and a custom number generator that generates 13-digit long numbers:

\begin{code}[caption=Custom data generators,label=custom]
// 4-character long hexadecimal string generator
"[A-F0-9]{4}"
// 13-digit long number generator
"\d{13}"
\end{code}

Note that the regular expression that specifies the number generator should only match representations that are valid JavaScript numbers, albeit in string format. The generated string is coerced to a number, therefore if a representation contains invalid characters, it will cause a \texttt{NaN} to be generated.

\section{Outcome}
\subsection{Output}
The role of the \textsf{Test Generator} is to generate \emph{candidate} tests, but the end goal of \textsf{Flycatcher} is to generate a suite of unit tests. So how is a candidate test elected to appear in the unit test suite? A candidate test is a useful unit test if it fulfils the following criteria:

\begin{itemize}
   \item It achieved \emph{new} coverage in the \textsf{Executor} (the current coverage is that achieved by other tests so far)
   \item It is valid \emph{i.e.} it contains no \texttt{Unknowns}
\end{itemize}

If a test fulfils those two criteria it is added to the suite of unit tests, which is output in a chosen format among a choice of JavaScript unit-testing frameworks. The current unit-testing formats available are \textsf{node-unit}, \textsf{expresso} and \textsf{Node.js}'s \textsf{assert} module. More framework formats may be available in the future. If none of these frameworks suit the user, the unit tests are output by default in simple JavaScript code with assertions. The unit-test suite output is meant to be a regression test suite. That is to say, all the tests in it pass when run with the current program under test. They are useful to uncover errors if the program under test changes and \emph{breaks} any of the unit-tests.

However, valid tests that failed inside the \textsf{Executor} due to an exception being thrown, are added to a log file for the user's attention. If the tests failed due to bugs or a lack of defensive programming, the user can use this feedback to fix these defects. If the tests failed because of an incorrect type inference, the user can adjust the delay before type inference, such that a better, more confident estimate is made.

\subsection{Timeouts}
A test may contain no \texttt{Unknowns} but still fail to ever achieve any new coverage, for example if a portion of the code is simply not reachable in the program. In this case, \textsf{Flycatcher} may loop as it may never achieve full coverage of a MUT. Hence, there are two timeouts in place to handle this scenario:

\begin{enumerate}
   \item a strict timeout in seconds
   \item a timeout characterised by aborting after a specific number of test runs during which coverage did not improve
\end{enumerate}

Both timeouts are user-configurable variables, specified by optional command line parameters (see usage in section \ref{usagesection}). Another reason than dead code for which new coverage might be unattainable is simply bugs in the program under test. Potential bugs may preclude any new coverage from being achieved because of thrown exceptions. The two timeouts also apply in this case, and the failing tests can be found in the logs. Note that two types of errors do not fit into this category: \emph{stack overflow} and \emph{infinite loops}. Due to the nature of these errors, the former crashes \textsf{Flycatcher} and the latter causes it to hang. Finally, if termination is not caused by timeouts, then \textsf{Flycatcher} stops generating tests for a MUT when it achieves its full coverage.\\

The next chapter is devoted to shedding light on the part of the implementation that has been left out so far: the responsibilities and inner workings of the custom execution environment or \textsf{Executor}.