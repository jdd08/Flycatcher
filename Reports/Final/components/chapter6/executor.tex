\chapter{Developing a custom runtime environment}
The tests that are generated by the \textsf{Test Generator} need to be executed by \textsf{Flycatcher} for two reasons:

\begin{enumerate}
   \item To collect runtime information about parameter types, such that tests with \emph{accurate} types can be generated --- only these \emph{valid} tests can be output and serve as unit tests
   \item To evaluate the code coverage achieved by valid tests, in order to elect the ones that make a difference
\end{enumerate}

To those ends, a custom runtime environment was created: the \textsf{Executor}. The \textsf{Executor} uses the same \textsf{vm} package used by the \textsf{Analyser} in order to create the runtime environment --- it just passes to it a sandbox with all of the elements that it wants to make available. In this chapter, we elaborate on how, in that environment, runtime type information is collected and code coverage is tracked for the MUT.

% *how* the information is collected (using proxies, hints etc.), how we do coverage (wrapping the MUT)s

\section{Collecting type information}
Collecting information at runtime about the types of parameters for method calls and constructor calls in candidate tests involves the \texttt{Unknown} type which was introduced in the previous chapter. However, for clarity, we simplified the declaration of \texttt{Unknown} objects in candidate tests as:

\begin{code}
var unknown = new Unknown();
\end{code}

\noindent In fact, these special objects that are capable of collecting type information at runtime require the following declaration instead, which we will elaborate on:

\begin{code}
var unknown = __proxy__(className, functionName, paramIndex);
\end{code}

The \_\_proxy\_\_ method is a special method\footnote{the name \_\_proxy\_\_ should avoid name clashes with classes in the program under test}, which creates a Proxy object tailored for type information collection, that we shall name \texttt{CollectorProxy} to be precise. The information is collected inside the \texttt{ProgramInfo} object, as discussed in chapter \ref{randomtest}. Hence, the \texttt{CollectorProxy}'s handler needs to be instantiated with information that lets it access the part of \texttt{ProgramInfo} corresponding to the parameter it stands for:

\begin{itemize}
   \item \texttt{className}: the parameter that the proxy stands for belongs to a function, that function belongs to a class --- this is the name of that class
   \item \texttt{functionName}: the parameter that the proxy stands for belongs to a function, this is the name of that function (which is identical to \texttt{className} in the case of a constructor)
   \item \texttt{paramIndex}: the parameter that the proxy stands for belongs to a function, this is the index of that parameter among the function's parameters
\end{itemize}

The type information collected at runtime takes two forms:

\begin{enumerate}
   \item Recording member accesses
   \item Accumulating a score for primitives
\end{enumerate}

\subsection{Recording member accesses}
The member accesses are recorded using the \texttt{get} trap of the \texttt{CollectorProxy}: the trap translates to \texttt{handler.get(receiver,name)} where name is the name of the property that was accessed. And we know from the initialisation of the \texttt{CollectorProxy}'s handler, where in \texttt{ProgramInfo} to store that information.

However, when a property is accessed, the \texttt{get} must return an appropriate object for execution to carry on. Much like in the \textsf{Analyser}, we return a \emph{Function Proxy} that can respond to any operation, but this is not to be confused with the \texttt{CollectorProxy} --- the proxy we return no longer stands for a parameter and as such does not collect any type information (its role is simply to avoid crashes). The only difference is that we randomise\footnote{\texttt{0} is returned more often as it is often a significant value in path exploration} the primitives returned by that proxy, so as to diversify the code exploration achieved by invalid candidate tests. Doing so diversifies our collection of type information in the early stages of the test generation process.

\subsection{Accumulating primitive scores}
The operators in table \ref{primitiveops}, when applied to operands, translate at a lower level into the internal function \texttt{[[getValue]]} being called on the operands. This function in turn calls the \texttt{valueOf} method on the members if they are objects, which instances of the \texttt{CollectorProxy} are. This enables the \texttt{CollectorProxys} to trap the requests to get the \texttt{valueOf} method, as they would any other method. Note that the operators: \texttt{\&\&, \textbar\textbar, !, =, === \textrm{and} !==} are missing from the table as they do not yield a \texttt{valueOf} call and thus cannot be trapped.

\begin{table}[h]
\hspace*{-0.5cm}
\centering
\begin{tabular}{lc}
\toprule
\emph{Arithmetic operators} & \texttt{+, -, *, /, \%, ++, \textendash\textendash, unary \textendash, unary +}\\
% \hline
\emph{Assignment Operators} & \texttt{*=, /=, \%=, +=, -=, \(\ll\)=, \(\gg\)=, \(\ggg\)=, \&=, \textasciicircum=, \textbar=}\\
% \hline
\emph{Bitwise Operators} & \texttt{\&, \textbar, \textasciicircum, \textasciitilde, \(\ll\), \(\gg\), \(\ggg\)}\\
% \hline
\emph{Comparison Operators} & \texttt{==, !=, >, >=, <, <=}\\
% \hline
\emph{String Operators} & \texttt{+, +=}\\
\bottomrule
\end{tabular}
\caption{Operators yielding \texttt{valueOf}}
\label{primitiveops}
\end{table}

% not in table:
% \textbf{Logical Operators} & \texttt{\&\&, \textbar\textbar, !} =, ===, !==


 % The primitive operations that involve a \texttt{CollectorProxy} are also recorded using the \texttt{get} trap, as they result in the internal \texttt{valueOf} function being called.
 
When the \texttt{valueOf} call is trapped, the handler only needs to compare the \texttt{name} in \texttt{handler.get(receiver,name)} to \texttt{valueOf} to determine whether it is dealing with a primitive operation. However, the problem is that \texttt{valueOf} does not teach us anything about what sort of primitive we are dealing with and we cannot use it to calculate scores for primitive types. This led us to develop the following steps in order to deduce a primitive score from a primitive operation:

\begin{enumerate}
   \item Determine if the \texttt{get} trap corresponds to a primitive operation \emph{i.e.} if it is a \texttt{valueOf} access
   \item If it is, throw an exception and \emph{catch it within the handler}
   \item In the \texttt{catch} body, use the Node.js \textsf{stack-trace}\footnote{\url{https://github.com/felixge/node-stack-trace}} module to retrieve the line where the primitive operation happened
   \item Scan that line of source code for \emph{hints} about the primitive type of the parameter
   \item Based on the hints found, increase the primitive scores in the score accumulator object
\end{enumerate}

Table \ref{scoringtable} shows the hints that are looked out for and the corresponding increases in primitive type scores. The scoring method in the table is not based on any formal heuristics, only on our extensive programming experience in JavaScript as well as experimentation. For example, if applied to a \emph{string}, the \texttt{++} operator yields a \texttt{TypeError}, hence why the \texttt{++} hint confers a particularly high score to the other type, \emph{number}.

\begin{table}[h]
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Hint} & \emph{number} & \emph{string}\\
\toprule
\texttt{++, \textendash\textendash}  & 10 & 0\\
\texttt{>, <}    & 2 & 1\\
\texttt{-, *, /, \%, \(\ll\), \(\gg\), \(\ggg\), \textasciicircum, \textbar, \&, \textasciitilde} & 2 & 0\\
\[[0 - 9]\]^{+}  & 5 & 0\\
double quotes\footnotemark & 0 & 5\\
\bottomrule
\end{tabular}
\caption{Primitive scoring}
\label{scoringtable}
\end{table}

\footnotetext{single quotes can be ignored, as if they appear in the context of the \textsf{Executor} it means that they harbour a double quote, which will be found}

Other operators or hints have been purposely omitted, since they do not tip the balance in any particular direction. For example, the \texttt{+} operator is used with strings as much as it is used with numbers, and thus does not constitute a helpful hint.

Step 4 of the above algorithm is carried out using regular expression matching. However, when searching for the hints in table \ref{scoringtable}, one must be careful not to match prefixes of other operators. For example, if the symbol found is a \texttt{\textendash\textendash} one must be careful not to match a single \texttt{\textendash}. The problem is that although the JavaScript RegExp syntax allows for \emph{negative lookahead} (matching unless the match is followed by something), it does not allow for \emph{negative lookbehind} (matching unless the match is preceded by something). Thankfully, the \textsf{XRegExp}\footnote{\url{"http://xregexp.com/"}} library compensates for that and provides the missing functionality.\\

In summary, the resulting primitive scores correspond, like the collection of member accesses, to information concerning the type of a particular parameter. This information is stored in the \texttt{ProgramInfo} object, and the \textsf{Test Generator} uses it to try and infer a type for that parameter.

\subsection{Trap threshold}
A certain issue was uncovered with the trapping mechanism devised for type collection: it could lead to the infinite execution of terminating programs. This was discovered with a JavaScript implementation of the Fibonacci algorithm:

\begin{code}[caption=Fibonacci in JavaScript]
Fibonacci.prototype.compute = function(n) {
    if (n>1) return this.compute(n-1) + this.compute(n-2);
    else return n;
}
\end{code}

The problem is that when the \texttt{>} and \texttt{\textendash} operators are called, they are trapped, and the value returned is not the result of the operation but a random value. Hence, the induction that makes the Fibonacci algorithm terminate is broken and a program which is supposed to terminate ends up hanging.

As a solution to this, a trap `threshold' was implemented, which only allows the \texttt{CollectorProxy} to trap 15 times. When the trap threshold is exceeded, the whole test is discarded. Given that trapping results in the collection of type information, upon a certain number of iterations, the parameter will change from an \texttt{Unknown} to a resolved type, and the infinite execution will have been avoided. The value of the trap threshold is not significant --- what matters is that it prevents infinite execution when the looping is due to the \texttt{Unknown} objects' behaviour.

Having discussed the collection of type information and its caveats, we now move on to discussing the second purpose of the \textsf{Executor}: tracking code coverage.

\section{Code coverage}

When doing \emph{structural testing} \emph{i.e.} testing the internal workings of a program, we are interested in executing as many paths as possible in that program, regardless of whether they are likely to be used in practice. The quality measure of a test in the context of structural testing, also known as \emph{white-box testing}, is therefore \emph{code coverage}, which reflects how error-free a program is. In practice, generating tests to cover every single possible execution path in a program is infeasible. Hence, in \textsf{Flycatcher}, we resort to a weaker measure of coverage: \emph{statement coverage}, which tracks the statements that are executed.

In \textsf{Flycatcher} the target of the output unit-testing suite is the CUT, as by default all of its methods are tested one by one. But as these methods each become the MUT, it is \emph{their} individual coverage that we are interested in. In other words, the candidate tests generated are geared towards a particular method each time, and it is the coverage achieved \emph{in that method} that can give us the quality of a test. Coverage in some other remote part of the program is not relevant to how well we are testing a particular method. Hence, code coverage needs to be tracked and reported for each MUT independently.\\

In order to do so, the following steps are necessary:
\begin{enumerate}
   \item When a MUT is selected, \emph{all the statements} in the definition of the MUT used by the \textsf{Executor} must be wrapped with a callback that updates coverage for that method
   \item The \textsf{Executor} environment must implement that callback
\end{enumerate}

\subsection{Wrapping the MUT statements}
Wrapping the MUT statements is done with the help of another \textsf{Node.js} package: \textsf{burrito}\footnote{\url{https://github.com/substack/node-burrito}}. Wrapping with that package is done like so:

\begin{code}[caption=Wrapping with \textsf{burrito},label=burrito]
var burrito = require("burrito");

var wrapped = burrito("foo()", function (node) {
    node.wrap("callback(%s)");
});

console.log(wrapped); // prints callback(foo());
\end{code}

However, in our case we are interested in attributing indices to statements such that when that portion of code executes, the callback registers that the statement with that index has been covered. The wrapping statement thus looks like this instead:

\begin{code}[caption=Wrapping in \textsf{Flycatcher}]
node.wrap("callback(" + index + "); %s;");
// where index is incremented when a new node is wrapped
\end{code}

However, the wrapping varies for different kinds of statements, as the calls to the callback have to be inserted in a way that they do not break JavaScript syntax and crash the program. For instance, in example \ref{wrappedfib}, the coverage callback called with index 2 pertains to the \texttt{return} statement and differs in format from the callbacks with indices 4 and 6 used to wrap the \texttt{compute} method calls.

\begin{code}[caption=Wrapped Fibonacci,label=wrappedfib]
Fibonacci.prototype.compute = function(n) {
  if (__coverage__(1)(n > 1)) {
    __coverage__(2);
    return __coverage__(3)(
               __coverage__(4)(this.compute(__coverage__(5)(n - 1))) +
               __coverage__(6)(this.compute(__coverage__(7)(n - 2)))
           );
  } else {
    __coverage__(8);
    return n;
  }
};
\end{code}

Hence, to track coverage in the \textsf{Executor} it was necessary to understand and adapt the wrapping process carried out by \textsf{burrito}. That wrapping process happens in three steps:

\begin{enumerate}
   \item The code is parsed into an AST using the parser from the \textsf{uglify-js}\footnote{\url{"https://github.com/mishoo/UglifyJS"}} module
   \item A wrapper function is mapped onto every node in the AST using the \textsf{traverse}\footnote{\url{"https://github.com/substack/js-traverse"}} module
   \item The transformed AST which contains the wrapped statements is rendered into code
\end{enumerate}

Therefore, understanding the wrapping process involved understanding and manipulating the AST, and wrapping its nodes appropriately. This was challenging because the AST in question is very poorly documented\footnote{the only pseudo-specification available is: \scriptsize{\url{"http://marijnhaverbeke.nl/parse-js/as.txt"}}}, and working with it was thus laborious. Nevertheless, due to its portability, we believe that using \textsf{burrito} for our instrumentation purposes was the best solution available. Indeed, the other coverage tools available for JavaScript were deeply embedded in a testing application and difficultly reusable by \textsf{Flycatcher}.

At the end of the instrumentation process, the list of indices used by the coverage callback serves as a representation for a MUT's statements. That list can be used to keep track of coverage inside the MUT.

\subsection{Implementing the callback}
The \textsf{Executor} must implement the coverage callback which is called when a statement is executed. This callback manipulates the list of indices gathered during the instrumentation process, updating it with the fact that a certain statement has been reached. In other words, it sets the value of the index it is called with to \texttt{true}. For example \ref{wrappedfib}, the list would initially be:

% if the MUT has 8 statements, at the beginning of its test generation process, its coverage tracker is:
\begin{code}
[false, false, false, false, false, false, false, false]
\end{code}

\noindent After the recursive case is executed it would be:

\begin{code}
[true, true, true, true, true, true, true, false]
\end{code}

\noindent And finally when the base case is executed:

\begin{code}
[true, true, true, true, true, true, true, true]
\end{code}

As a result of this coverage mechanism, the \textsf{Executor} can report:

\begin{itemize}
   \item Whether a test achieves any \emph{new} coverage for a MUT, and is therefore a useful test to be output in the unit-test suite
   \item What the current total code coverage for a MUT is, which is used to inform the user of coverage progress, and terminate upon full coverage
\end{itemize}

% TODO corner case where class only has valueOf method...
% Hence, information can be collected using the following \texttt{get} trap:
% ProgramInfo => members accessed and primitive score
% \chapter{Search-based Test Generator}