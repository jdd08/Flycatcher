\chapter{Executor}
The tests that are generated by the \textsf{Random Test Generator} need to be executed by \textsf{Flycatcher} for two reasons:

\begin{enumerate}
   \item To collect runtime information about parameter types, such that tests with \emph{accurate} types can be generated --- only these \emph{valid} tests can be output and serve as unit tests
   \item To evaluate the code coverage achieved by valid tests, in order to elect the `best' ones
\end{enumerate}

To those ends, a bespoke runtime environment was created: the \textsf{Executor}. The \textsf{Executor} uses the same \textsf{vm} package used by the \textsf{Analyser}, in order to create that bespoke execution environment --- it just passes it a sandbox with all of the elements that it wants to make available. In this chapter, we elaborate on how in that environment, runtime type information is collected and code coverage is tracked for the MUT.

% *how* the information is collected (using proxies, hints etc.), how we do coverage (wrapping the MUT)s

\section{Collecting type information}
Collecting information at runtime about the types of parameters for method calls and constructor calls in candidate tests involves the \texttt{Unknown} type which was introduced in the previous chapter. However, for clarity we simplified the declaration of \texttt{Unknown} objects in candidate tests as:

\begin{code}
var unknown = new Unknown();
\end{code}

\noindent In fact, these special objects that are capable of collecting type information at runtime require the following declaration instead, which we will elaborate on:

\begin{code}
var unknown = __proxy__(className, functionName, paramIndex);
\end{code}

The \_\_proxy\_\_ method is a special method\footnote{the name \_\_proxy\_\_ should avoid name clashes with classes in the program under test}, which creates a Proxy object, that we shall name \texttt{RecordingProxy} to be precise, tailored for type information collection. The information is collected inside the \texttt{ProgramInfo} object, as discussed in chapter \ref{randomtest}. Hence, the \texttt{RecordingProxy}'s handler needs to be instantiated with information that lets the proxy access the part of \texttt{ProgramInfo} corresponding to the parameter it stands for:

\begin{itemize}
   \item \texttt{className}: the parameter that the proxy stands for belongs to a function, that function belongs to a class --- this is the name of that class
   \item \texttt{functionName}: the parameter that the proxy stand for belongs to a function, this is the name of that function (which is identical to \texttt{className} in the case of a constructor)
   \item \texttt{paramIndex}: the parameter that the proxy stands for belongs to a function, this is the index of that parameter among the function's parameters
\end{itemize}

The type information collected at runtime takes two forms:

\begin{enumerate}
   \item Recording member accesses
   \item Accumulating a score for primitives
\end{enumerate}

\subsection{Recording member accesses}
The member accesses are easily recorded using the \texttt{get} trap of the \texttt{RecordingProxy}: the trap translates to \texttt{handler.get(receiver,name)} where name is the name of the property that was accessed, and we know from the initialisation of the \texttt{RecordingProxy}'s handler, where in \texttt{ProgramInfo} to store that information.

When a property is accessed however, the \texttt{get} must return an appropriate object for the execution to carry on. Much like in the \textsf{Analyser}, we return a Function Proxy that can respond to any operation, but this is not to be confused with the \texttt{RecordingProxy} type --- the proxy we return no longer stands for a parameter and as such does not collect any type information (it's role is simply not to crash). The only difference is that we randomise the primitives returned by that proxy, so as to diversify the code exploration achieved by invalid candidate tests. Doing so diversifies our collection of type information in the early stages of the test generation process.

\subsection{Accumulating primitive scores}
The primitive operations that involve an \texttt{RecordingProxy} are also recorded using the \texttt{get} trap, as they result in the internal \texttt{valueOf} function being called. Hence, the handler need only compare the name in \texttt{handler.get(receiver,name)} to \texttt{valueOf} to determine whether it is dealing with a primitive operation. Where this becomes more involved however, is that \texttt{valueOf} does not teach us anything about what sort of primitive we are dealing with and we cannot use it to calculate scores for primitive types. This led us to the develop the following steps in order to deduce a primitive score from a primitive operation:

\begin{enumerate}
   \item Determine if the \texttt{get} trap corresponds to a primitive operation \emph{i.e.} if it is a \texttt{valueOf} access
   \item If it is, throw an exception and \emph{catch it within the handler}
   \item In the \texttt{catch} body, use the Node.js \textsf{stack-trace}\footnote{\url{https://github.com/felixge/node-stack-trace}} module to retrieve the line where the primitive operation happened
   \item Scan that line of source code for \emph{hints} about the primitive type of the parameter
   \item Based on the hints found, increase the primitive scores in the score accumulator object
\end{enumerate}

Table \ref{scoringtable} shows the hints that are looked out for and by how much the score of a primitive type is increased when a hint is encountered. We recall that the only primitive types considered are \emph{number} and \emph{string} as we consider that the \emph{boolean} values \texttt{true} and \texttt{false} can be substituted by \texttt{1} and \texttt{0} respectively. The scoring method in the table is not based on any formal heuristics, only on our extensive programming experience in JavaScript as well as experimentation. For example, if applied to a \emph{string}, the \texttt{++} operator yields a \texttt{TypeError}, hence why the \texttt{++} hint confers a particularly high score to the other type, \emph{number}.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Hint} & \emph{number} & \emph{string}\\
\hline
\texttt{++, \textendash\textendash}  & 10 & 0\\
\texttt{>, <}    & 2 & 1\\
\texttt{-, *, /, \%, \(\ll\), \(\gg\), \(\ggg\), !, \textasciicircum, \textbar, \&, \textasciitilde} & 2 & 0\\
\[[0 - 9]\]^{+}  & 5 & 0\\
\texttt{``\textellipsis''} & 0 & 5\\
\hline
\end{tabular}
\caption{Primitive scoring}
\label{scoringtable}
\end{table}

Other operators or hints have been purposely omitted, since they do not tip the balance in any particular direction. For example, the \texttt{+} operator is used with strings as much as it is used with numbers, and thus does not constitute a helpful hint.

In summary, the resulting primitive scores correspond, like the collection of member accesses, to information concerning the type of a particular parameter. This information is stored in the \texttt{ProgramInfo} object, and the \textsf{Random Test Generator} uses it to try and infer a type for that parameter. Having discussed the collection of type information, we move on to discussing the second mission of the \textsf{Executor}: tracking code coverage.

\section{Code coverage}

When doing \emph{structural testing} \emph{i.e.} testing the internal workings of a program, we are interested in executing as many paths as possible in that program, regardless of whether they are likely to be used in practice. The quality measure of a test in the context of structural testing, also known as \emph{white-box testing}, is therefore \emph{code coverage}, which reflects how error-free a program is. In practice, generating tests to cover every single possible execution path in a program is infeasible. Hence, we have to resort to weaker coverage measures such as \emph{branch coverage} which tracks the truth values at every branching statement, or simply \emph{statement coverage}, which tracks the statements that are executed. In \textsf{Flycatcher} we chose to implement the basic measure of \emph{statement coverage}, in order to focus the bulk of our efforts on the test generation process itself.

In \textsf{Flycatcher} the target of the output unit-testing suite is the CUT, as by default all of its methods are tested one by one. But as these methods each become the MUT, it is \emph{their} individual coverage that we are interested in. In other words, the generated tests are geared towards a particular method each time, and it is the coverage achieved \emph{in that method} that can give us the quality of a test. For example, when using code coverage as a heuristic to \emph{improve} the tests being generated for a MUT, coverage in some other remote part of the program is not relevant. Hence, code coverage needs to be tracked and reported for each MUT independently.\\

In order to do so, the following steps are necessary:
\begin{enumerate}
   \item When a MUT is selected, in the source code that is run by the \textsf{Executor}, \emph{all the statements} in the definition of the MUT must be wrapped with a callback that updates coverage for that method
   \item The \textsf{Executor} environment must implement that callback
\end{enumerate}

\subsection{Wrapping the MUT statements}
Wrapping the MUT statements is done with the help of another Node.js package: \textsf{burrito}\footnote{\url{https://github.com/substack/node-burrito}}. Thanks to that package, wrapping is made relatively simple:

\begin{code}[caption=Wrapping with \textsf{burrito},label=burrito]
   var burrito = require("burrito");
   
   var wrapped = burrito("foo()", function (node) {
       node.wrap("callback(%s)");
   });
   
   console.log(wrapped); // prints callback(foo());
\end{code}

However, in our case we are interested in attributing node indices to statements/nodes such that when that portion of code executes, the callback registers that the node with that index is covered. The wrapping statement thus looks like this instead:

\begin{code}
node.wrap("callback(" + index + "); %s;");
// where index is incremented when a new node is wrapped
\end{code}

At the end of this wrapping process, the full array of indices used thus represents all of the MUT's statements. That array can be used to keep track of coverage.

\subsection{Implementing the callback}
The \textsf{Executor} must implement the coverage callback which is called when a statement is executed. The implementation itself is trivial: the callback must simply set the value of the node index it is called with to \texttt{true}. For example, if the MUT has nine nodes/statements, at the beginning of its test generation process, its coverage tracker is:

\begin{code}
[false, false, false, false, false, false, false, false, false]
\end{code}

\noindent If the first and last node are executed, it becomes:

\begin{code}
[true, false, false, false, false, false, false, false, true]
\end{code}

As a result, the \textsf{Executor} can report:

\begin{itemize}
   \item Whether a test achieves any new coverage for a MUT, and is therefore a useful test to be output in the unit-test suite
   \item What the current total code coverage for a MUT is, which is used in the various termination criteria of the test generation process for that method
\end{itemize}

% TODO corner case where class only has valueOf method...
% Hence, information can be collected using the following \texttt{get} trap:
% ProgramInfo => members accessed and primitive score

% \chapter{Search-based Test Generator}
\chapter{Evaluation}
\chapter{Conclusion}

\appendix
\chapter{Examples}