var dump = require('../../utils.js').dump;

var burrito = require('burrito');
var vm = require('vm');
var EventEmitter = require('events').EventEmitter;

module.exports = function (src) {
    var b = new Bunker();
    if (src) b.include(src);
    return b;
};

function Bunker () {
    this.sources = [];
    this.nodes = [];
    this.cov = [];
    this.names = {
        call : burrito.generateName(6),
        expr : burrito.generateName(6),
        stat : burrito.generateName(6)
    };
}

Bunker.prototype = new EventEmitter;

Bunker.prototype.addSource = function (src) {
    this.sources.push(src);
    return this;
};

Bunker.prototype.instrumentMUT = function (name,func,CUT) {
    var nodes = this.nodes;
    var names = this.names;
    var cov = this.cov;
    var funcDef = CUT + ".prototype.MUT = "+func.toString();
    var b = burrito(funcDef, function (node) {
        var i = nodes.length;
        if (node.name === 'call') {
            nodes.push(node);
            cov.push({src:node.source(),exec:false});
            node.wrap(names.call + '(' + i + ')(%s)');
        }
        else if (node.name === 'stat' || node.name === 'throw'
        || node.name === 'var') {
            nodes.push(node);
            cov.push({src:node.source(),exec:false});
            node.wrap('{' + names.stat + '(' + i + ');%s}');
        }
        else if (node.name === 'binary') {
            nodes.push(node);
            cov.push({src:node.source(),exec:false});
            node.wrap(names.expr + '(' + i + ')(%s)');
        }
        else if (node.name === 'unary-postfix' || node.name === 'unary-prefix') {
            nodes.push(node);
            cov.push({src:node.source(),exec:false});
            node.wrap(names.expr + '(' + i + ')(%s)');
        }
        // if the node does not correspond to any of the node types above
        // (like the very last one) no need to set its id as this node is
        // effectively ignored (it is not pushed onto the nodes array)
        if (i !== nodes.length) {
            node.id = i;
        }
    });
    return {r: b, cov: cov};
};

Bunker.prototype.assign = function (context) {
    if (!context) context = {};
    
    var self = this;
    var stack = [];
    
    context[self.names.call] = function (i) {
        var node = self.nodes[i];
        stack.unshift(node);
        self.emit('node', node, stack);
        
        return function (expr) {
            stack.shift();
            return expr;
        };
    };
    
    context[self.names.expr] = function (i) {
        var node = self.nodes[i];
        self.emit('node', node, stack);
        
        return function (expr) {
            return expr;
        };
    };
    
    context[self.names.stat] = function (i) {
        var node = self.nodes[i];
        self.emit('node', node, stack);
    };
    
    return context;
};
    
Bunker.prototype.displaySource = function() {
    dump(this.sources.join('\n'),"f");
}
    
Bunker.prototype.run = function (context) {
    
    // TODO compile the method under test only (whose definition can be gotten from a dynamic object)
    //      using this compiled version, encapsulate it in a Proxy and append the whole thing to the source
    //      the methods in the test must be called *on the proxy* the lines executed can be compared to the
    //      nodes collected when instrumenting the MUT
    var src = this.sources.join('\n');
    vm.runInNewContext(src, this.assign(context));
    return this;
};
